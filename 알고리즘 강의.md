# 알고리즘 강의



## 1. 스택과 큐

스택 자료구조

- 먼저 들어온 데이터가 나중에 나가는 형식 (선입후출)

- 삽입 & 삭제
- 리스트 자료형 (append, pop)
  - 출력시에도 최하단 원소부터 출력
  - 최상단 원소부터 출력하려면? `print(stack[::-1])`

큐 자료구조

- 먼저 들어온 데이터가 먼저 나가는 형식 (선입선출)
- 입구와 출구가 모두 뚫려 있는 터널을 생각하면 됨

- deque() 라이브러리 이용

  ```python
  from collections import deque
  
  queue = deque()
  
  queue.append() # 오른쪽으로 들어와서
  queue.popleft() # 왼쪽으로 나감
  
  print(queue) # 먼저 들어온 원소부터 출력
  queue.reverse() # 역순으로 바꾸기
  print(queue) # 나중에 들어온 원소부터 출력
  ```

  

## 2. 우선순위 큐 (Priority Queue)

- 우선순위 큐:  우선순위가 가장 높은 데이터를 가장 먼저 삭제

- 구현 방법
  - 리스트를 이용하여 구현
  
  - 힙(heap)을 이용하여 구현
  
  - 데이터의 개수가 N개일 때, 구현 방식에 따라서 시간 복잡도를 비교
  
    | 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
    | ------------ | --------- | --------- |
    | 리스트       | O (1)     | O (N)     |
    | 힙           | O (logN)  | O (logN)  |
  
  - Heap: N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일 (시간복잡도: O(NlogN))

- Heap의 특징

  - 완전 이진 트리 자료구조

    - 루트 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순으로 차례대로 데이터가 삽입되는 트리

  - 항상 루트 노드를 제거

  - 최소 힙

    - 루트 노드가 가장 작은 값을 가짐 -> 가장 값이 작은 데이터가 우선 제거

    - 최소 힙 구성 함수: Min-Heapify()
      - 새로운 데이터가 들어왔을 때 최소 힙 성질을 만족하지 않는 서브트리가 있으면 Min-Heapify()를 통해 재정렬
      - 원소가 제거되었을 때 마지막 노드가 루트 노드의 위치에 오도록  -> 루트 노드에서부터 하향식으로 Heapify() 진행
      - 시간 복잡도: O (logN)

  - 최대 힙

    - 루트 노드가 가장 큰 값을 가짐 -> 가장 값이 큰 데이터가 우선 제거

```python
import sys
import heapq # 기본적으로 minheap형태, 오름차순 정렬
input = sys.stdin.readline

def heapsort(iterable):
    h = []
    result = []
    # 모든 원소를 차례대로 힙에 삽입
    for value in iterable:
        heapq.heappush(h, value)
    # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기 : 값이 작은 것부터 오름차순
    for i in range(len(h)):
        result.append(heapq.heappop(h))
    return result

n = int(input())

arr = []

for i in range(n):
    arr.append(int(input()))

res = heapsort(arr)

for i in range(n):
    print(res[i])
```



## 3. 트리 (Tree)

트리: 가계도와 같은 계층적 구조를 표현할 때 사용

- 루트 노드: 부모가 없는 최상위 노드
- 단말 노드: 자식이 없는 노드
- 크기: 트리에 포함된 모든 노드의 개수
- 깊이: 루트 노드부터의 거리
- 높이: 깊이 중 최댓값
- 차수: 각 노드의 (자식 방향) 간선 개수

트리의 크기가 N개일 때, 전체 간선의 개수는 N-1



이진탐색 트리

- 이진 탐색이 동작할 수 있도록 고안
- 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
- 탐색 예시: 37
  - 부모노드: 30 -> 37은 30보다 크므로 오른쪽으로 이동: 48 
  - 48의 자식노드: 37  VS 50 -> 37은 48보다 작으므로 왼쪽으로 이동: 37



트리의 순회

- 노드를 특정한 방법으로 한 번씩 방문
  - 트리의 정보를 시각적으로 확인 가능
- 전위 순회: 루트 먼저 -> 왼쪽
- 중위 순회: 왼쪽 자식 먼저 -> 루트
- 후위 순회: 오른쪽 자식 먼저 -> 루트



## 4. 바이너리 인덱스 트리

boj 구간합 구하기 문제 https://www.acmicpc.net/problem/2042



바이너리 인덱스 트리: 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결

- 팬윅 트리라고도 함
- 정수에 따른 2진수 표기

- 특정한 숫자 k의 0이 아닌 마지막 비트를 찾는 방법: k & -k
  - 0 : 0
  - 1 : 1
  - 2 : 2
  - 3 : 1
  - 4 : 4
  - 5 : 1
  - 6 : 2
  - 7 : 1
  - 8 : 8
