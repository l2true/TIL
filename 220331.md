# 220331ğŸ•



## í•©ì„±ê³± ì‹ ê²½ë§ (Convolution Neural Network, CNN)



### 1. ë„ì… ë°°ê²½

- ê¸°ê³„ê°€ ì´ë¯¸ì§€ë¥¼ ì¸ì‹í•˜ëŠ” ë°©ë²•?

-> í”½ì…€ ë‹¨ìœ„ë¡œ ìª¼ê°œì„œ (28 * 28)

-> flattení•˜ì—¬ ì¸ì‹ (1 * 784)



- ì‚¬ëŒì€ ëª¨ì–‘ìœ¼ë¡œ ì¸ì‹í•¨

-> ì´ì²˜ëŸ¼ 'ìœ„ìƒ' ë³€í™”ì˜ ì˜í–¥ì„ ë°›ì§€ ì•Šê³  ì´ë¯¸ì§€ë¥¼ ì–´ë–»ê²Œ í•™ìŠµí•  ìˆ˜ ìˆì„ê¹Œ?



- ëŒ€ë‡Œ ì‹œê°í”¼ì§ˆ ì‹¤í—˜

ê³ ì–‘ì´ëŠ” ì‚¬ì„ í˜• edgeë¥¼ detectí•  ìˆ˜ ìˆìŒ

-> ê¸°ìš¸ì–´ì§„ í¬ê³  ì‘ì€ edge ìš”ì†Œë“¤ì˜ í•©ì„± ê³¼ì •ì„ í†µí•´ ì „ì²´ ì´ë¯¸ì§€ë¥¼ êµ¬ì„±í•¨



- ì´ë¯¸ì§€ë¥¼ ì–´ë–»ê²Œ ì¸ì‹í•  ìˆ˜ ìˆì„ê¹Œ?

  - **ì´ë¯¸ì§€ì˜ ìœ¤ê³½ì„ ì°¾ì•„ë‚´ê¸° ->** **kernel ê¸°ë²•**(x_trainì˜ ìœ¤ê³½ì„ ì¸ì‹)

  - ì–´ë–¤ ì‚¬ë¬¼ì¸ì§€ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆì„ê¹Œ -> ìœ¤ê³½ì— label ë¶™ì´ê¸° (y_trainìœ¼ë¡œ ì •ë‹µì„ ë„£ê¸°)




### 2. Kernel ê¸°ë²• 

#### 1) Convolution (í•©ì„±ê³±)

- kernel ê¸°ë²•: í–‰ë ¬ë¼ë¦¬ convolution ì—°ì‚°í•˜ëŠ” ê²ƒ

- Convolution ì—°ì‚°

  - **ì¼ì • ì˜ì—­ì˜ ê°’ë“¤(window)**ì— ëŒ€í•´ **ê°€ì¤‘ì¹˜(kernel = filter)**ë¥¼ ì ìš©í•˜ì—¬ í•˜ë‚˜ì˜ ê°’ì„ ë§Œë“œëŠ” ì—°ì‚°


  - ë‘ ê°œì˜ ì‹ í˜¸ë¥¼ **í•©ì„±**í•´ì„œ ë‚´ë³´ë‚´ëŠ” ì—°ì‚° (ê³±í•œ í›„ ì ë¶„)


1. windowì™€ kernelì„ ê°™ì€ ìë¦¬(í–‰,ì—´)ì— í•´ë‹¹í•˜ëŠ” ìˆ˜ë¼ë¦¬ ê³±í•˜ê³ (ìš”ì†Œê³±) ëª¨ë‘ ë”í•˜ê¸°

2. ì˜†ìœ¼ë¡œ í•œ ì¹¸ ì´ë™í•´ì„œ ë‹¤ì‹œ í•©ì„±ê³±
3. ì²«ë²ˆì§¸ ìë¦¬ì—ì„œ ë°‘ìœ¼ë¡œ í•œ ì¹¸ ì´ë™í•´ì„œ í•©ì„±ê³±
4. ì˜†ìœ¼ë¡œ í•œ ì¹¸ ì´ë™í•´ì„œ í•©ì„±ê³±



#### 2) CNN

- Convolutionì—°ì‚°ì„ ì´ìš©í•œ network

- CNNì—ì„œ í•™ìŠµì„ í†µí•´ì„œ ë‚˜ì˜¤ëŠ” modelì˜ ê°€ì¤‘ì¹˜ë“¤ì€ ë¬´ì—‡ì´ í•™ìŠµë˜ëŠ” ê±¸ê¹Œ?

  - kernelê°’ì´ í•™ìŠµëœë‹¤

- kernelê°’ì´ í•™ìŠµë  ìˆ˜ë¡ ì´ë¯¸ì§€ì˜ íŠ¹ì§•ì„ ì¶”ì¶œí•˜ê²Œ ëœë‹¤.

- ì¶”ì¶œëœ íŠ¹ì§•ì„ ì¶”ìƒí™”ì‹œì¼œ ì´ë¯¸ì§€ë¥¼ ë¶„ë¥˜í•  ìˆ˜ ìˆë‹¤.

  

#### 3) Kernelë¡œ ì´ë¯¸ì§€ ë¶ˆëŸ¬ì˜¤ê¸°

```python
from PIL import Image, ImageFilter
import matplotlib.pyplot as plt

# wget: ì›¹ì—ì„œ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œ ë°›ì„ ìˆ˜ ìˆëŠ” í”„ë¡œê·¸ë¨
!wget https://i.imgur.com/K85HUBK.jpeg

# ì´ë¯¸ì§€ ì €ì¥
origin_img = Image.open("./K85HUBK.jpeg")

# ì´ë¯¸ì§€ ì—´ê¸°
display(origin_img)

# ì»¤ë„1 ë§Œë“¤ê¸° 
edge_1 = [
          1, 0, -1, 
          1, 0, -1, 
          1, 0, -1
]

# imageì— filter ì”Œìš°ê¸°
convol_img = origin_img.filter(ImageFilter.Kernel((3,3), edge_1, 1, 0))

# ì´ë¯¸ì§€ ì—´ê¸°
display(convol_img)

# ì´ë¯¸ì§€ì— ì»¤ë„2ë¥¼ ì”Œìš°ê³  ì´ë¯¸ì§€ ì—´ê¸°
edge_2 = [
          0, 1, 0, 
          0, 1, 0, 
          0, 1, 0
]

convol_img2 = origin_img.filter(ImageFilter.Kernel((3,3), edge_2, 1, 0))

display(convol_img2)
```

- kernelì˜ ë°©í–¥ì— ë”°ë¼ ë¹›ì„ ë°›ëŠ” ë°©í–¥ì´ ë‹¬ë¼ì§€ê±°ë‚˜ íŠ¹ì„±ì´ ë‹¬ë¼ì§
  - [ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ kernel](https://en.wikipedia.org/wiki/Kernel_(image_processing))

- kernelì˜ ê°¯ìˆ˜ì— ë”°ë¼ ì¶œë ¥ channelì˜ ê°œìˆ˜ ê²°ì •ë¨



#### 3) íŒ¨ë”© (Padding)

paddingì²˜ë¦¬: í•©ì„±ê³± ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ì „ì— ì…ë ¥ ë°ì´í„° ì£¼ë³€ì„ 0ê³¼ ê°™ì€ íŠ¹ì • ê°’ìœ¼ë¡œ ì±„ìš°ëŠ” ê²ƒ

- **ì¶œë ¥ í¬ê¸°ë¥¼ ì¡°ì •**í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•¨

- ex) (4 x 4 + padding1) * (3 x 3) = 4 x 4

![image-20220404001942452](220331.assets/image-20220404001942452.png)



#### 4) ìŠ¤íŠ¸ë¼ì´ë“œ (Stride)

í•„í„°ë¥¼ ì ìš©í•˜ëŠ” ìœ„ì¹˜ì˜ ê°„ê²©

![image-20220404145642126](220331.assets/image-20220404145642126.png)



#### 5) Pooling (í’€ë§)

- ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” ì •ë³´ë¥¼ ìµœëŒ€/ìµœì†Œ/í‰ê· ê°’ìœ¼ë¡œ ì••ì¶•í•˜ì—¬ **ë°ì´í„° ì—°ì‚°ëŸ‰ì„ ì¤„ì—¬ì£¼ëŠ”** ì—­í•  ìˆ˜í–‰

- 2ì°¨ì› ë°ì´í„°ì˜ ì„¸ë¡œ ë° ê°€ë¡œ ë°©í–¥ì˜ ê³µê°„ì„ ì¤„ì´ëŠ” ì—°ì‚°

- conv ì—°ì‚°ì˜ ê²°ê³¼ë¥¼ ëŒ€í‘¯ê°’ì„ ì¶”ì¶œí•´ë‚´ëŠ” ê³¼ì •

  - **ìµœëŒ€ í’€ë§(max)**: ì˜ì—­ì—ì„œ ìµœëŒ“ê°’ì„ ì·¨í•¨ -> ì´ë¯¸ì§€ ì¸ì‹ ë¶„ì•¼ì—ì„œ ì£¼ë¡œ ì‚¬ìš©

  - **ìµœì†Œ í’€ë§(min)**:  ì˜ì—­ì˜ ìµœì†Ÿê°’

  - **í‰ê·  í’€ë§(average)**: ì˜ì—­ì˜ í‰ê· ê°’ì„ ê³„ì‚°


![image-20220404145733565](220331.assets/image-20220404145733565.png)

![image-20220404174247515](220331.assets/image-20220404174247515.png)



### 2. MNIST ì†ê¸€ì”¨ ë°ì´í„° ì˜ˆì¸¡

#### 1) ê°’ ì˜ˆì¸¡í•˜ê¸°

```PYTHON
import tensorflow as tf 
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist

# MNIST ë°ì´í„°ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°
(x_train,y_train), (x_test, y_test) = mnist.load_data()

# ì •ë‹µ ë°ì´í„° ì›-í•« ì¸ì½”ë”©
y_train = tf.keras.utils.to_categorical(y_train)
y_train[0] # array([0., 0., 0., 0., 0., 1., 0., 0., 0., 0.], dtype=float32)
# ì°¸ê³ 
# loss function ì„ SparseCategoricalCrossentropy ì„ ì´ìš©í•´ í•™ìŠµí•œë‹¤ë©´
# onehot encoding ì„ í•´ì¤„ í•„ìš”ì—†ë‹¤. 
# https://www.tensorflow.org/api_docs/python/tf/keras/losses/SparseCategoricalCrossentropy

# ëª¨ë¸ ìƒì„±
x_train.shape # ë°ì´í„° í˜•íƒœ í™•ì¸ (60000, 28, 28)

model = tf.keras.Sequential()

# convolution layer
model.add(tf.keras.layers.Conv2D(filters=64, kernel_size= (3,3), activation = "relu", input_shape=(28, 28, 1))) # output: 64ê°œ ì´ë¯¸ì§€
model.add(tf.keras.layers.MaxPooling2D(pool_size=2)) # 64ê°œ ì´ë¯¸ì§€ ì¶•ì†Œ
model.add(tf.keras.layers.Conv2D(filters=128, kernel_size= (3,3), activation = "relu")) # inputì´ 64ê°œ, outputì´ 128ê°œ ì´ë¯¸ì§€
model.add(tf.keras.layers.MaxPooling2D(pool_size=2)) # 128ê°œ ì´ë¯¸ì§€ ì¶•ì†Œ

# dense layer
model.add(tf.keras.layers.Flatten())  # ì¶”ì¶œëœ íŠ¹ì§•ì„ ì¶”ìƒí™”
model.add(tf.keras.layers.Dense(units=128, activation="relu")) #ì¶”ìƒí™”ëœ ê°’ë“¤ì˜ íŒ¨í„´ì„ í•™ìŠµ
model.add(tf.keras.layers.Dense(units=64, activation="relu")) #ì¶”ìƒí™”ëœ ê°’ë“¤ì˜ íŒ¨í„´ì„ í•™ìŠµ
model.add(tf.keras.layers.Dense(units=10, activation="softmax"))  # ë¶„ë¥˜

# ëª¨ë¸ í•™ìŠµ
model.compile(loss="categorical_crossentropy", optimizer= "adam", metrics=["accuracy"])
model.fit(x_train, y_train, batch_size = 1024, epochs=3) 

# ëª¨ë¸ ì˜ˆì¸¡
model.predict(x_test[0].reshape((1,28,28))) # array([[2.6022948e-07, 4.9259668e-08, 2.0601020e-04, 
                                            # 5.7503569e-04,3.2923658e-08, 2.9364080e-07, 2.9958514e-07, 
                                            # 9.9848312e-01, 5.7871810e-05, 6.7706214e-04]], dtype=float32)
np.argmax(model.predict(x_test[0].reshape((1,28,28)))) # ìµœëŒ“ê°’: 7

# ì •ë‹µ í™•ì¸
y_test[0] # 7

# confusion matrixë¡œ ì •ë‹µ í™•ì¸
from sklearn.metrics import confusion_matrix

p_test = model.predict(x_test).argmax(axis=1)
confusion_matrix(y_test, p_test) # true ê°’ê³¼ Predict ê°’ì„ ë¹„êµí•˜ì—¬ matrix ë¡œ í‘œí˜„í•œë‹¤. (ì˜ í•™ìŠµë˜ì§€ ì•ŠëŠ” ìš”ì†Œë¥¼ ì•Œìˆ˜ ìˆë‹¤. )

#np.where true false ë¥¼ í†µí•´ í‹€ë¦° ê°’ì˜ indexë¥¼ ì¶”ì¶œ
miss_id = np.where(p_test != y_test)[0] 
i = np.random.choice(miss_id) #í•˜ë‚˜ì”© ì¶”ì¶œí•´ì„œ í™•ì¸
plt.imshow(x_test[i])
plt.title(f"true:{y_test[i]}, predict:{p_test[i]}")
```

![image-20220406144510333](220331.assets/image-20220406144510333.png)

![image-20220406144730220](220331.assets/image-20220406144730220.png)

#### 2) ì˜ˆì¸¡ ê°’ì˜ í™€ìˆ˜ ì—¬ë¶€ íŒë‹¨

- inputdata = image 

- output = ì§ìˆ˜, í™€ìˆ˜ íŒë‹¨
- ex) ìˆ«ì 7 ì¸ ì´ë¯¸ì§€ë¥¼ input -> [0,0,0,0,0,0,0,1,0,0], [1]

```python
import tensorflow as tf 
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.datasets import mnist
from tensorflow.python.keras.utils.vis_utils import plot_model

# MNIST ë°ì´í„°ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°
(x_train,y_train), (x_test, y_test) = mnist.load_data()

# ì •ë‹µ ë°ì´í„° ì›-í•« ì¸ì½”ë”©
y_train = tf.keras.utils.to_categorical(y_train)
y_train[:5] # array([[0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],..., dtype = float32)

# ì •ë‹µ ë°ì´í„°ë¥¼ í™€ìˆ˜ëŠ” 1, ì§ìˆ˜ëŠ” 0ì¸ arrayë¡œ ë§Œë“¤ê¸°
y_train_odd = [] 
for i in y_train:
  if i % 2 == 0 :
    y_train_odd.append(0)
  else:
    y_train_odd.append(1)
y_train_odd = np.array(y_train_odd)

y_train_odd[:5] # array([1, 0, 0, 1, 1])

# ëª¨ë¸ ìƒì„± (Functional ë°©ì‹) # ì½”ë“œ ì„¤ëª…: flattenì™œ ë‘ë²ˆ? concatenateëŠ” ë­”ì§€?
# ë…¸ë“œ ë§Œë“¤ê¸°
input = tf.keras.layers.Input(shape=(28,28,1), name="input")

conv_1 = tf.keras.layers.Conv2D(64, (3,3), activation="relu", name="conv_1")(input)
pool_1 = tf.keras.layers.MaxPooling2D((2,2), name="maxpool_1")(conv_1)
conv_2 = tf.keras.layers.Conv2D(128, (3,3), activation="relu", name="conv_2")(pool_1)
pool_2 = tf.keras.layers.MaxPooling2D((2,2), name="maxpool_2")(conv_2)

flatten_1 = tf.keras.layers.Flatten(name="flatten_1")(pool_2)
flatten_2 = tf.keras.layers.Flatten(name="flatten_2")(input)

concat = tf.keras.layers.Concatenate()([flatten_1,flatten_2])

num_out = tf.keras.layers.Dense(10, activation="softmax", name ="num_out")(concat)
odd_out = tf.keras.layers.Dense(1, activation="sigmoid", name="odd_out")(flatten_2)

model = tf.keras.models.Model(inputs=input, outputs=[num_out, odd_out])

# ëª¨ë¸ì— ì‚¬ìš©ë˜ëŠ” ë…¸ë“œ í™•ì¸
model.summary()

# compile
# num_out: softmaxí•¨ìˆ˜ -> ë‹¤ì¤‘ ë¶„ë¥˜ (0~1)
# odd_out: sigmoidí•¨ìˆ˜ -> ì´ì§„ ë¶„ë¥˜ (0,1)
model.compile(optimizer="adam",
              loss={"num_out":"categorical_crossentropy", "odd_out":"binary_crossentropy"},
              metrics=["accuracy"])

# ëª¨ë¸ í•™ìŠµ
model.fit({"input": x_train}, {"num_out":y_train, "odd_out":y_train_odd},
          epochs=5)

# ëª¨ë¸ ì˜ˆì¸¡
y_num, y_odd = model.predict(x_test[1].reshape(1,28,28))

# ì˜ˆì¸¡ê°’ í™•ì¸
y_num # array([[0., 0., 1., 0., 0., 0., 0., 0., 0., 0.]], dtype=float32)

# í™€ìˆ˜ ì—¬ë¶€ ì˜ˆì¸¡ í™•ì¸
np.round(y_odd) # array([[0.]], dtype=float32)

# ì •ë‹µ í™•ì¸
plt.imshow(x_test[1])
y_test[1] # 2
```



### 3. Fashion_mnist ë°ì´í„°ì…‹ í•™ìŠµ

Mnist ë°ì´í„°ì…‹ í•™ìŠµí•  ë•Œì™€ model ì€ ê°™ì§€ë§Œ datasetì´ ë°”ë€œì— ë”°ë¼ modelì˜ ìš©ë„ê°€ ë³€ê²½ëœë‹¤. 

```PYTHON
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

fashtion_mnist = tf.keras.datasets.fashion_mnist
(x_train, y_train), (x_test, y_test) = fashtion_mnist.load_data()

plt.imshow(x_train[0])
fashtion_mnist.load_data?

set(y_train) # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

# ìˆ«ì mnistì™€ ê°™ì€ model ì´ë‹¤. 
model = tf.keras.Sequential()
model.add(tf.keras.layers.Conv2D(filters=64, kernel_size= (3,3), activation = "relu", input_shape=(28, 28,1)))
model.add(tf.keras.layers.MaxPooling2D(pool_size=2))
model.add(tf.keras.layers.Conv2D(filters=128, kernel_size= (3,3), activation = "relu"))
model.add(tf.keras.layers.MaxPooling2D(pool_size=2))
model.add(tf.keras.layers.Flatten())
model.add(tf.keras.layers.Dense(units=128, activation="relu"))
model.add(tf.keras.layers.Dense(units=64, activation="relu"))
model.add(tf.keras.layers.Dense(units=10, activation="softmax"))

model.compile(loss="sparse_categorical_crossentropy", optimizer="adam", metrics=["accuracy"])
model.fit(x_train, y_train, batch_size=1024, epochs=4)

# ì˜ˆì¸¡
np.round(model.predict(x_test[0].reshape(1,28,28))) # array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 1.]], dtype=float32)
y_test[0] # ì •ë‹µê°’ í™•ì¸: 9

# confusion matrix
from sklearn.metrics import confusion_matrix
p_test = model.predict(x_test).argmax(axis=1)
confusion_matrix(y_test, p_test)

miss_id = np.where(p_test != y_test)[0]
i = np.random.choice(miss_id)
plt.imshow(x_test[i])
plt.title(f"true:{y_test[i]}, predict:{p_test[i]}")

model.predict(x_test[i].reshape(1,28,28)) # array([[1.5479356e-01, 3.8992381e-04, 4.1643709e-01, 7.5892109e-04, 7.8588547e-03, 3.4834441e-06, 3.5630846e-01, 2.5665244e-05, 5.9715178e-02, 3.7088657e-03]], dtype=float32)
```

![image-20220406151802069](220331.assets/image-20220406151802069.png)

![image-20220406151830502](220331.assets/image-20220406151830502.png)

model ì—ì„œ layer0 ë¥¼ ë”°ë¡œ ë–¼ì–´ì„œ ìƒˆë¡œìš´ modelì„ ìƒì„±í•˜ê³ , kernelë“¤ì„ ê°ê° í™•ì¸í•´ë³´ê¸°

```python
from tensorflow.keras import models

# í•™ìŠµëœ modelì˜ layerì™€ output ê°’ì„ ì €ì¥í•œë‹¤.
layer_outputs = [layer.output for layer in model.layers[:1]]

# model.input : ì›ë˜ model ì˜ input layer
# layer_outputs : model.layers ì˜ í•™ìŠµëœ kernel layer
activation_model = models.Model(inputs=model.input, outputs=layer_outputs)

activations = activation_model.predict(x_test[0].reshape(1,28,28))
activations.shape[-1] # 64

features = activations.shape[-1] # activation_modelì„ í†µê³¼í•œ ê²°ê³¼ì˜ ì´ë¯¸ì§€ ê°¯ìˆ˜
size = activations.shape[1] # í†µê³¼í•œ ì´ë¯¸ì§€ ê²°ê³¼ì˜ í¬ê¸° 
plt.figure(figsize=(5,5))
for i in range(features):
  plt.subplot(4,activations.shape[-1]/4, i+1)
  plt.subplots_adjust()
  plt.imshow(activations[0,:,:,i])
plt.tight_layout()
```

![image-20220406152816332](220331.assets/image-20220406152816332.png)



### 4. Tensor Hub ëª¨ë¸ ì´ìš©í•˜ê¸°

tensorhub ë¥¼ ì´ìš©í•´ ì´ë¯¸ í•™ìŠµëœ model ì„ ë¶ˆëŸ¬ì˜¬ìˆ˜ ìˆë‹¤. 

ì´ë¯¸ì§€ ì† ë¬¼ì²´ë¥¼ ì¸ì‹í•˜ëŠ” faster_rcnn ëª¨ë¸ ì‹¤ìŠµ

```python
import tensorflow as tf
import tensorflow_hub as tfhub
import matplotlib.pyplot as plt

model = tfhub.load("https://tfhub.dev/google/faster_rcnn/openimages_v4/inception_resnet_v2/1")

# ëª¨ë¸ ìš©ë„ í™•ì¸
# í•˜ë‚˜ì˜ ëª¨ë¸ì´ë¼ë„ signaturesì— ë”°ë¼ì„œ ë‹¤ì–‘í•œ ìš©ë„ê°€ ì¡´ì¬í• ìˆ˜ ìˆìŒ. 
# model ì‚¬ìš©ì „ì— signatures ì§€ì •
model.signatures.keys()

fast_rcnn = model.signatures["default"] # default: ìš©ë„ 1ê°œì„ (object detect)

type(fast_rcnn) # tensorflow.python.eager.wrap_function.WrappedFunction

img_path = "https://imgnews.pstatic.net/image/656/2022/03/31/0000007281_001_20220331095802286.jpg"
img = tf.keras.utils.get_file(origin=img_path)
img = tf.image.decode_jpeg(tf.io.read_file(img), 3)
img = tf.image.convert_image_dtype(img, tf.float32)

plt.imshow(img)

img_resize = tf.expand_dims(img, 0) # ë°°ì¹˜ì¶”ê°€
img_resize.shape # TensorShape([1, 279, 540, 3])

result = fast_rcnn(img_resize)# ì¶”ë¡ ê³¼ì •
result.keys() # ì¶”ë¡  ê²°ê³¼ í™•ì¸ 
# dict_keys(['detection_class_labels', 'detection_class_entities', 'detection_scores', 'detection_class_names', 'detection_boxes'])

#ê²°ê³¼ í‘œí˜„ 
boxes = result["detection_boxes"]
labels = result["detection_class_entities"]
scores = result["detection_scores"]

obj_num = 15

img_height = img.shape[0]
img_width = img.shape[1]

plt.figure(figsize=(15,10))
for i in range(obj_num):
  y_max, x_min = boxes[i][0] * img_height, boxes[i][1] * img_width
  y_min, x_max = boxes[i][2] * img_height, boxes[i][3] * img_width
  plt.imshow(img)
  plt.plot([x_min, x_max,x_max,x_min,x_min],[y_min,y_min, y_max, y_max,y_min], color="yellow")
  name=labels[i].numpy().decode("utf-8")
  score = int(scores[i].numpy()*100)
  name_score = f"{name}: {score}%"
  plt.text(x=x_min, y=y_max, s=name_score, color="white", backgroundcolor="red")
    
labels[0].numpy().decode("utf-8") # Man
```

![image-20220406153709632](220331.assets/image-20220406153709632.png)

![image-20220406153730061](220331.assets/image-20220406153730061.png)
